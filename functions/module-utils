# Finds which compiler module is loaded
get_compiler_module() {
  local ccmod
  for ccmod in $(find /shared/ucl/apps/modulefiles/compilers -type f | cut -d'/' -f7-)
    do
    /shared/ucl/apps/modules/3.2.6/Modules/3.2.6/bin/modulecmd bash list 2>&1 | grep "${ccmod}" >/dev/null
    if [ $? -eq 0 ]
      then
      echo "${ccmod}"
      break
    fi
  done
}

# Constructs the modulefile name by taking the compiler module (e.g.
# compilers/intel/2015/update2), stripping off the leading 'compilers/' and
# and replacing the remaining '/'s with '-' (e.g. intel-2015-update2).
get_module_string() {
  local ccmod
  ccmod="$(get_compiler_module)"
  [ "${ccmod}" ] || die "Unable to find compiler module"
  local modstring
  modstring="${ccmod#*/*}"
  echo "${modstring//\//-}"
}

# Constructs the modulefile path as
# ${PREFIX}/modulefiles/${PN}/${PV}/${MODULE_STRING}
get_module_file() {
  local modstring
  modstring="$(get_module_string)"
  [ "${modstring}" ] || die "Unable to construct module string"
  echo "${MODULE_FILE:-${PREFIX}/modulefiles/${PN}/${PV}/${modstring}}"
}

write_module_file() {
  local modfile
  modfile="$(get_module_file)"
  [ "${modfile}" ] || die "Unable to get module file path"
  local module_depstring=""
  for dep in ${MODULE_DEPENDS}
    do
    module_depstring="${module_depstring}
prereq ${dep}"
  done
  mkdir -p "${modfile%/*}" && \
  cat > "${modfile}" <<EOF
#%Module -*- tcl -*-
##
## dot modulefile
##
proc ModulesHelp { } {
puts stderr "\tAdds ${PN}"
}

module-whatis "${DESCRIPTION}"

set             root            ${DESTDIR}

conflict ${PN}
prereq $(get_compiler_module)${module_depstring}

append-path LD_RUN_PATH       \$root/lib
append-path LD_LIBRARY_PATH   \$root/lib
append-path CMAKE_PREFIX_PATH \$root
append-path CPATH             \$root/include
append-path INCLUDE_PATH      \$root/include
append-path LIBRARY_PATH      \$root/lib

setenv  ${PN}_LIBRARY_DIR     \$root/lib
setenv  ${PN}_INCLUDE_DIR     \$root/include
EOF
}
